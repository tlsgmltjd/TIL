# 스프링부트 요청과 응답 과정

**카페와 빵집이 있다고 가정해보자.**

- 카페는 커피, 빵집은 빵은 판다.
- 필요한 경우 협업 관계를 맺어 어떤 손님이 커피를 사면 빵을 할인해줄 수 있다.
  > 이것이 계층 간의 소통이다.
- 하지만 빵집 알바생이 빵을 팔다 말고 카페에 가서 커피를 팔순 없다.

  > 즉 계층은 서로 영향을 미칠 수 없다.

- 이렇게 각 계층은 서로 영향을 미치진 못한다. 이렇게 각 계층은 자신의 책임에 맞는 역할을 수행하며, 필요에 따라 소통한다.

**스프링부트에선 프레젠테이션, 비지니스, 퍼시스턴스 계층이 있디.**

> 이 계층이 서로 소통하며 프로그램을 구성한다.

`[프레젠테이션 계층](Controller) <-> [비지니스 계층](Service) <-> [퍼시스턴스 계층](Repository) <-> [데이터베이스]`

### 프레젠테이션 계층

- HTTP 요청을 받고 이 요청을 비즈니스 계층으로 전송하는 역할이다.
- 컨트롤러

### 비즈니스 계층

- 모든 비즈니스 로직을 처리한다.
  > 비즈니스 로직 - 서비스를 만들기 위한 로직이다. 웹 사이트에서 일어난 모든 작업, ex. (주문 서비스) 주문 개수, 기격 등의 데이터를 처리하기 위한 로직, 주문 처리 중 발생한 예외 처리 로직, 주문을 받거나 취소하기 위한 로직등이다.
- 서비스

### 퍼시스턴스 계층

- 모든 데이터베이스 관련 로직을 처리한다.
  - 데이터베이스에 접근하는 DAO 객체를 사용할 수 있다.
    > DAO - 데이터베이스 계층과 상호작용하기 위한 객체
- 레포지토리

---

### 프레젠테이션, 비즈니스, 퍼시스턴스 만들기

**프레젠테이션 계층**

```java
@RestController
public class TestController {
    @Autowired
    TestService testService;

    @GetMapping("/test")
    public List<Member> getAllMembers() {
        List<Member> members = testService.getAllMembers();
        return members;
    }
}
```

**비즈니스 계층**

```java
@Service
public class TestService {
    @Autowired
    MemberRepository memberRepository;

    public List<Member> getAllMembers() {
        return memberRepository.findAll();
    }
}
```

- `MemberRepository`라는 빈을 주입받은 후에 `findAll()` 메서드를 호출하여 맴버 테이블에 저장된 모든 맴버를 가져온다.

`HTTP요청 (/test)` -> `TestController(프레젠테이션)` -> `TestService(비즈니스)`

**DAO**

- DB에 접근하는 코드이다.
- member 테이블과 Member 클래스를 매핑하는 코드이다.

```java
@NoArgsConstructor(access = AccessLevel.PROTECTED)
@AllArgsConstructor
@Getter
@Setter
@Entity
public class Member {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "id", updatable = false)
    private Long id;

    @Column(name = "name", nullable = false)
    private String name;
}

```

**퍼시스턴스 계층**

- 매핑 작업을 위해 인터페이스 파일이 필요하다.
- member 테이블에 접근해 Member 클래스를 매핑하는 구현체이다.

```java
public interface MemberRepository extends JpaRepository<Member, Long> {
}
```

---

**더미데이터**

- `resources/data.sql`

```sql
INSERT INTO member (id, name) VALUES (1, 'name 1');
INSERT INTO member (id, name) VALUES (2, 'name 2');
INSERT INTO member (id, name) VALUES (3, 'name 3');
```

**application.yml 설정**

```yml
spring:
  jpa:
    # 전송 쿼리 확인
    show-sql: true
    properties:
      hibernate:
        format_sql: true

    # 테이블 생성 후에 data.sql 실행
    defer-datasource-initialization: true
```

- 실행시 이렇게 테이블이 생성되는 로그를 확인할 수 있다.

```sql
Hibernate:
    drop table if exists member cascade
Hibernate:
    create table member (
        id bigint generated by default as identity,
        name varchar(255) not null,
        primary key (id)
    )
```

### 결과 확인

- `localhost:8080/test` 로 HTTP 요청을 보낼 시 `data.sql` 에 작성한 더미데이터가 응답으로 온다.

```json
[
  {
    "id": 1,
    "name": "name 1"
  },
  {
    "id": 2,
    "name": "name 2"
  },
  {
    "id": 3,
    "name": "name 3"
  }
]
```

---

### 스프링 부트 요청 - 응답 과정

- 브라우저가 /test GET 요청을 톰켓에 보낸다. 그러면 이 요청은 스프링부트 내로 이동시킨다.
- 이때 스프링부트의 **디스페치 서블릿**이 URL을 분석하고 이 요청을 처리할 수 있는 컨트롤러에 전달한다.
- /test GET 요청을 처리할 수 있는 getAllMembers() 메서드와 이 요청이 매치된다.
- 비즈니스 계층과 퍼시스턴스 계층을 통하면서 필요한 데이터를 가져온다.
- 뷰 리졸버가 템플릿 엔진을 이용해 HTML 문서를 만들거나 JSON. XML 등의 데이터를 생성한다.
- members를 return하고 데이터를 브라우저에서 볼 수 있게 된다.
